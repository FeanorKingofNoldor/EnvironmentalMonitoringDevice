// File: src/main.cpp
#include <Arduino.h>
#include <WiFi.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

// Core framework
#include "core/EventBus.h"
#include "core/Config.h"
#include "core/BaseClasses.h"
#include "core/Managers.h"

// Device-specific implementation
#include "device/EnvironmentalDevice.h"

// Communication
#include "communication/APIClient.h"
#include "communication/DisplayUART.h"

// Build information (generated by build script)
#ifdef BUILD_INFO_H
#include "build_info.h"
#endif

// Global device coordinator
DeviceCoordinator deviceCoordinator;

// Communication managers
APIClient apiClient;
DisplayUART displayUART;

// FreeRTOS task priorities
#define PRIORITY_CRITICAL   20
#define PRIORITY_HIGH       15
#define PRIORITY_MEDIUM     10
#define PRIORITY_LOW        5

#define STACK_SIZE_LARGE    8192
#define STACK_SIZE_NORMAL   4096
#define STACK_SIZE_SMALL    2048

// Task handles
TaskHandle_t systemTaskHandle = nullptr;
TaskHandle_t communicationTaskHandle = nullptr;
TaskHandle_t displayTaskHandle = nullptr;

// Forward declarations
void systemTask(void* parameter);
void communicationTask(void* parameter);
void displayTask(void* parameter);

void setup() {
    Serial.begin(115200);
    delay(2000); // Allow serial monitor to connect
    
    // Print startup banner
    Serial.println("\n" + String('=', 50));
    Serial.println("AeroEnv Environmental Controller");
    #ifdef FIRMWARE_VERSION
    Serial.println("Firmware Version: " + String(FIRMWARE_VERSION));
    #endif
    #ifdef BUILD_TIME
    Serial.println("Build Date: " + String(BUILD_TIME));
    #endif
    #ifdef BUILD_GIT_HASH
    Serial.println("Git Hash: " + String(BUILD_GIT_HASH));
    #endif
    Serial.println(String('=', 50) + "\n");
    
    // Initialize device capabilities
    config.setDeviceCapabilities(&environmentalDevice);
    deviceCoordinator.setDeviceCapabilities(&environmentalDevice);
    
    Serial.println("Starting system initialization...");
    
    // Initialize core system
    if (!initializeCore()) {
        Serial.println("FATAL: Core system initialization failed");
        ESP.restart();
    }
    
    // Initialize device-specific components
    if (!initializeDevice()) {
        Serial.println("FATAL: Device initialization failed");
        ESP.restart();
    }
    
    // Start system tasks
    if (!startSystemTasks()) {
        Serial.println("FATAL: Failed to start system tasks");
        ESP.restart();
    }
    
    Serial.println("System initialization complete - entering main loop");
    
    // Publish system startup event
    eventBus.publish(CoreEventTypes::SYSTEM_STARTUP, "main", 
                    "{\"device_type\":\"" + environmentalDevice.getDeviceType() + 
                    "\",\"version\":\"" + environmentalDevice.getFirmwareVersion() + "\"}");
}

void loop() {
    // Main loop runs at low priority - just monitoring
    static unsigned long lastHeartbeat = 0;
    static unsigned long heartbeatInterval = 10000; // 10 seconds
    
    unsigned long currentTime = millis();
    
    // Periodic heartbeat
    if (currentTime - lastHeartbeat >= heartbeatInterval) {
        Serial.printf("System heartbeat - Uptime: %lu ms, Free heap: %u bytes\n", 
                     currentTime, ESP.getFreeHeap());
        lastHeartbeat = currentTime;
    }
    
    // Check for critical system issues
    if (ESP.getFreeHeap() < 10000) { // Less than 10KB free heap
        Serial.println("WARNING: Low memory condition detected");
        PUBLISH_SYSTEM_ERROR("main", "Low memory warning");
    }
    
    // Yield to other tasks
    vTaskDelay(pdMS_TO_TICKS(1000));
}

bool initializeCore() {
    Serial.println("Initializing core systems...");
    
    // Initialize configuration system
    if (!config.begin()) {
        Serial.println("ERROR: Failed to initialize configuration system");
        return false;
    }
    
    // Initialize device coordinator (includes all managers)
    if (!deviceCoordinator.begin()) {
        Serial.println("ERROR: Failed to initialize device coordinator");
        return false;
    }
    
    Serial.println("Core systems initialized successfully");
    return true;
}

bool initializeDevice() {
    Serial.println("Initializing environmental device components...");
    
    // Device-specific initialization happens in managers via device capabilities
    // This is handled by the DeviceCoordinator
    
    // Initialize communication components
    if (!apiClient.begin()) {
        Serial.println("WARNING: API client initialization failed - continuing without cloud connectivity");
    }
    
    if (!displayUART.begin()) {
        Serial.println("WARNING: Display UART initialization failed - continuing without display");
    }
    
    Serial.println("Device components initialized");
    return true;
}

bool startSystemTasks() {
    Serial.println("Starting system tasks...");
    
    // System management task (highest priority)
    xTaskCreatePinnedToCore(
        systemTask,
        "SystemTask",
        STACK_SIZE_NORMAL,
        nullptr,
        PRIORITY_CRITICAL,
        &systemTaskHandle,
        1 // Pin to core 1
    );
    
    if (systemTaskHandle == nullptr) {
        Serial.println("ERROR: Failed to create system task");
        return false;
    }
    
    // Communication task (medium priority)
    xTaskCreatePinnedToCore(
        communicationTask,
        "CommTask",
        STACK_SIZE_NORMAL,
        nullptr,
        PRIORITY_MEDIUM,
        &communicationTaskHandle,
        0 // Pin to core 0
    );
    
    if (communicationTaskHandle == nullptr) {
        Serial.println("ERROR: Failed to create communication task");
        return false;
    }
    
    // Display communication task (low priority)
    xTaskCreatePinnedToCore(
        displayTask,
        "DisplayTask",
        STACK_SIZE_SMALL,
        nullptr,
        PRIORITY_LOW,
        &displayTaskHandle,
        0 // Pin to core 0
    );
    
    if (displayTaskHandle == nullptr) {
        Serial.println("ERROR: Failed to create display task");
        return false;
    }
    
    Serial.println("All system tasks started successfully");
    return true;
}

// High-priority system management task
void systemTask(void* parameter) {
    Serial.println("System task started");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(100); // 10Hz update rate
    
    while (true) {
        // Update device coordinator (handles all managers)
        deviceCoordinator.update();
        
        // Check for system errors and handle them
        if (deviceCoordinator.getState() == ManagerState::ERROR) {
            Serial.println("CRITICAL: System error detected in device coordinator");
            String error = deviceCoordinator.getLastError();
            Serial.println("Error: " + error);
            
            PUBLISH_SYSTEM_ERROR("SystemTask", error);
            
            // Attempt recovery
            vTaskDelay(pdMS_TO_TICKS(5000)); // Wait 5 seconds
            
            Serial.println("Attempting system recovery...");
            // deviceCoordinator.restartSystem(); // Implement if needed
        }
        
        // Wait for next cycle
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// Communication management task
void communicationTask(void* parameter) {
    Serial.println("Communication task started");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000); // 1Hz update rate
    
    while (true) {
        // Update API client
        if (apiClient.isReady()) {
            apiClient.update();
        }
        
        // Handle WiFi connection
        static unsigned long lastWiFiCheck = 0;
        if (millis() - lastWiFiCheck > 30000) { // Check every 30 seconds
            if (WiFi.status() != WL_CONNECTED) {
                Serial.println("WiFi disconnected, attempting reconnection...");
                NetworkConfig netConfig = config.getNetwork();
                if (!netConfig.wifiSSID.isEmpty()) {
                    WiFi.begin(netConfig.wifiSSID.c_str(), netConfig.wifiPassword.c_str());
                }
            }
            lastWiFiCheck = millis();
        }
        
        // Wait for next cycle
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// Display communication task
void displayTask(void* parameter) {
    Serial.println("Display task started");
    
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(100); // 10Hz update rate
    
    while (true) {
        // Update display UART communication
        if (displayUART.isReady()) {
            displayUART.update();
        }
        
        // Wait for next cycle
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

// Error handling
extern "C" void app_error_fault_handler(void* pc, void* lr, void* sp, void* cause) {
    Serial.printf("FATAL ERROR: PC=%p LR=%p SP=%p CAUSE=%p\n", pc, lr, sp, cause);
    Serial.flush();
    ESP.restart();
}

// Stack overflow hook
extern "C" void vApplicationStackOverflowHook(TaskHandle_t xTask, char* pcTaskName) {
    Serial.printf("STACK OVERFLOW in task: %s\n", pcTaskName);
    Serial.flush();
    ESP.restart();
}

// Malloc failed hook
extern "C" void vApplicationMallocFailedHook(void) {
    Serial.println("MALLOC FAILED - out of memory");
    Serial.flush();
    ESP.restart();
}